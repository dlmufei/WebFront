正则表达式（应用）
===

* 在线测试
  * [regexp 在线可视化工具](https://regexper.com/)（[github，本地安装方法](https://github.com/javallone/regexper-static)）
  * [RegExp在线工具-站长工具](http://tool.oschina.net/regex/)

* JavaScript-RegExp对象
  * 初始化的方式：
    >（1）字面量 `var reg=/\bis\b/g;`如：`'he is my love'.replace(reg,'was');`  
    >（2）构造函数 `var reg =new RegExp('\\bis\\b','g');`
  * 对象属性
    >|属性|说明|
    >|---|----|    
    >|`global`|是否全文搜索，默认false,只读|
    >|`ignoreCase`|是否大小写敏感，默认false，只读|
    >|`multiline`|多行搜索，默认值false，只读|
    >|`lastIndex`|当前正则表达式匹配内容的最后一个字符的下一个位置(即下一次匹配开始的位置)。<br>**注意：**（`test()`方法执行后的结果会作用域这个属性）|
    >|`source`|正则表达式的文本字符串。|
  * 对象方法
    >|方法|说明|
    >|---|----|    
    >| `test(str)` |用于判断字符中是否有正则匹配的字符，有则返回true；否则返回false。<br>**注意：**（`test()`方法执行后的结果会作用域这个属性）|
    >|`exec(str)`|1.非全局状态下，正则属性lastIndex总是为0，不起作用。exec方法只是匹配指定字符串一次，一旦匹配成功了，则不会继续匹配了。<br>2.全局状态下，exec方法是从头到尾的去匹配指定的字符串，匹配字符串中所有符合正则表达式的字符。而每次匹配的位置则依据lastIndex的值来开始搜索。<br>3.返回值：如果没有匹配的文本则返回null，则返回一个结果数组：<br>- index 声明匹配文本的第一个字符位置 <br>- input 存放被检索的字符串 string|

* JavaScript-String对象与RegExp相关
  * `search(reg)`：检索与正则表达式相匹配的字符串，返回第一个匹配的index或者-1；不执行全局搜索，忽略`/g`,总是从第一个开始匹配。
  * `match(reg)`：找到一个或者多个与reg匹配的文本。
  对`/g`敏感，结果返回数组。
  <br>（1）非全局：数组第一个元素存放匹配文本，后面依次存放与正则表达式的分组表达式匹配的文本。以及数组的两个属性：
  <br>index - 匹配文本起始字符在字符串中的位置。
  <br>input - 对string对象的引用。
  <br>（2）全局：数组中存放的是字符串中匹配的所有子串，注意：不是正则表达式的分组表达式匹配的文本，即没有分组信息了。也没有index和input属性。
  * `split(reg)`：根据正则规则分割成数组。
  * `replace(reg)`：根据正则规则进行。
  <br>String.prototype.replace(str,replaceStr)
  <br>String.prototype.replace(reg,replaceStr)
  <br>String.prototype.replace(reg,function)
  <br>function参数含义:
    - 匹配字符串
    - 正则表达式分组内容，没有分组则没有该参数
    - 匹配项在字符串中 index
    - 原字符串

* 修饰符
  * g:global,全局搜索，若没有，则只搜索到第一个匹配停止。
  * i:ignore case,忽略大小写，默认大小写敏感。
  * m:multiple lines 多行搜索。

* 正则表达式的两种基本字符类型
  * 原义文本字符：代表字符本身的意思，如：`a`,`b`
  * 元字符：有特殊含义的非字母字符
* 字符类：  
使用元字符`[]`构建，泛指符合某个特征的对象，如：`[abc]`把`a`或`b`或`c`归为一类。
* 范围类：  
`[a-z]`匹配小写字母，`[a-zA-Z]`大写小写完全匹配。`[a-z-]`匹配小写字母外，还包括`-`字符。
* 预定义类：  
  >|  字符  |       等价类            |                     含义                |
  >|--------|------------------------|-----------------------------------------|
  >|`.`     |      `[^\r\n]`         |      包含除回车符和换行符以外其他的字符    |
  >|`\d`    |       `[0-9]`          |      数字字符                            |
  >|`\D`    | `[^0-9]`               |      非数字字符                          |
  >|`\s`    |`[\t\n\x0B\f\r]`        |      空白符                              |
  >|`\S`    |`[^\t\n\x0B\f\r]`        |      非空白符                           |
  >|`\w`    |`[a-zA-Z_0-9]`        |     单词字符（字母、数字、下划线）           |
  >|`\W`    |`[^a-zA-Z_0-9]`        |           非单词字符                      |
* 边界字符
  >|   字符  |        含义      |
  >|---------|-----------------|
  >|`^`|以xxx开始|
  >|`$`|以xxx结束|
  >|`\b`|单词边界|
  >|`\B`|非单词边界|
* 量词  
如：要求连续匹配出现20次的数字的字符串，若写成`\d\d\d\d\d\d\d\d\d\d\`这样太难看了。
  >|   字符  |        含义      |
  >|---------|-----------------|
  >|`？`|出现零次或者一次（最多出现1次）|
  >|`+`|出现1次或者多次（最少出现1次）|
  >|`*`|出现0次或者多次（出现任意次|
  >|`{n}`|出现n次|
  >|`{n,m}`|出现n到m次|
  >|`{n,}`|最少出现n次|
  >|`{0,n}`|最多出现n次|
* 贪婪模式与非贪婪模式
  * 贪婪模式：就是尽可能多的进行匹配`'12345678'.replace('/\d{3,6}/g','X')` 会一直匹配到1~6；
  * 非贪婪模式：在量词后面加`?`,如：`'12345678'.replace('/\d{3,6}?/g','X')` 会分别匹配`123`和`456` ；
* 分组  
就是作为一个整体来处理，因为一般的匹配字符的作用域仅限于相邻的词。如`hello{3}`,代表的只是`o`出现了三次。
  * 使用`()`来达到分组的功能，如`(hello){3}`,代表的只是`hello`出现了三次。
  * `‘或’ | `  -分组内使用`|`,表示匹配两边的都可以。如：`(hello|hi){3}`,连续匹配`hello`或`hi`都行。
  * **反向引用**：引用匹配好的字符串，使用`$1`………`$n`这样来表示（注意：需要配合分组来使用）。
  * **忽略分组**：不希望捕获某些分组，只需要在分组内加上`? :`即可。
* 前瞻  
  正则表达式从文本头部向尾部开始解析，文本尾部方向，成为“前”。
  **前瞻** 就是在正则表达式匹配到规则的时候，向前检查是否符合断言。比如找到儿子为张三，还得看看他的父亲是否是李四。
  * 后顾/后瞻方向相反
  * 注意：JavaScript不支持后顾
  * 符合特定断言称为 **肯定/正向** 匹配
  * 不符合特定断言称为 **否定/负向** 匹配 
  * **正向前瞻** `exp（？=assert）` 先判断是否符合正则，再符合正则的基础上判断是否符合断言
  * **负向前瞻** `exp（？！asseret）`







------
参考

* [JavaScript正则表达式-慕课网](http://www.imooc.com/learn/706)